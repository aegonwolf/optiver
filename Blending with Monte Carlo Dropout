{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8b37f78e",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:20.132260Z",
     "iopub.status.busy": "2022-03-16T17:22:20.131598Z",
     "iopub.status.idle": "2022-03-16T17:22:21.279244Z",
     "shell.execute_reply": "2022-03-16T17:22:21.278480Z",
     "shell.execute_reply.started": "2021-09-27T11:50:11.959965Z"
    },
    "papermill": {
     "duration": 1.188012,
     "end_time": "2022-03-16T17:22:21.279467",
     "exception": false,
     "start_time": "2022-03-16T17:22:20.091455",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from scipy.special import gamma\n",
    "import pandas as pd\n",
    "import numpy as np # linear algebra\n",
    "import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
    "import glob\n",
    "import os\n",
    "import gc\n",
    "from joblib import Parallel, delayed\n",
    "from sklearn.model_selection import GroupKFold\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "path_submissions = '/'\n",
    "\n",
    "target_name = 'target'\n",
    "scores_folds = {}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "de614988",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.337392Z",
     "iopub.status.busy": "2022-03-16T17:22:21.336716Z",
     "iopub.status.idle": "2022-03-16T17:22:21.340602Z",
     "shell.execute_reply": "2022-03-16T17:22:21.341035Z",
     "shell.execute_reply.started": "2021-09-27T11:50:12.935796Z"
    },
    "papermill": {
     "duration": 0.033133,
     "end_time": "2022-03-16T17:22:21.341249",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.308116",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def tau(series):\n",
    "    return 1 / np.sqrt(np.sum(series)/(np.sum(series)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "c01ffada",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.398141Z",
     "iopub.status.busy": "2022-03-16T17:22:21.396794Z",
     "iopub.status.idle": "2022-03-16T17:22:21.406094Z",
     "shell.execute_reply": "2022-03-16T17:22:21.406644Z",
     "shell.execute_reply.started": "2021-09-27T11:50:12.943266Z"
    },
    "papermill": {
     "duration": 0.039781,
     "end_time": "2022-03-16T17:22:21.406833",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.367052",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def num_positive(series):\n",
    "    return (series > 0).sum()\n",
    "\n",
    "def num_negative(series):\n",
    "    return (series < 0).sum()\n",
    "\n",
    "def pos_neg_ratio(series):\n",
    "    if num_negative(series) == 0:\n",
    "        return num_positive(series)\n",
    "    else:\n",
    "        return num_positive(series) / num_negative(series)\n",
    "    \n",
    "def realized_1(series):\n",
    "    return np.sqrt(np.sum(series**4)/(6*np.sum(series**2)))\n",
    "\n",
    "def realized_2(series):\n",
    "    return np.sqrt(((np.pi**2)*np.sum(abs(series.rolling(window=4).apply(np.product, raw=True))))/(8*np.sum(series**2)))\n",
    "\n",
    "def realized_3(series):\n",
    "    numerator = (gamma(1/2)**3)*np.sum((abs(series)**(4/3)).rolling(window=3).apply(np.prod))\n",
    "    denominator = 8 * (gamma(7/6)**3)*np.sum(series**2)\n",
    "    return np.sqrt(numerator/denominator)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "cd5d2b91",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.463115Z",
     "iopub.status.busy": "2022-03-16T17:22:21.462148Z",
     "iopub.status.idle": "2022-03-16T17:22:21.469263Z",
     "shell.execute_reply": "2022-03-16T17:22:21.469745Z",
     "shell.execute_reply.started": "2021-09-27T11:50:12.956786Z"
    },
    "papermill": {
     "duration": 0.037208,
     "end_time": "2022-03-16T17:22:21.469975",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.432767",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def realized_quarticity(series):\n",
    "    return np.sum(series**4)*series.shape[0]/3\n",
    "\n",
    "def realized_quadpower_quarticity(series):\n",
    "    series = abs(series.rolling(window=4).apply(np.product, raw=True))\n",
    "    return (np.sum(series) * series.shape[0] * (np.pi**2))/4\n",
    "\n",
    "from scipy.special import gamma\n",
    "def realized_tripower_quarticity(series):\n",
    "    series = series ** (4/3)\n",
    "    series = abs(series).rolling(window=3).apply(np.prod, raw=True)\n",
    "    return series.shape[0]*0.25*((gamma(1/2)**3)/(gamma(7/6)**3))*np.sum(series)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "37e46d32",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.528053Z",
     "iopub.status.busy": "2022-03-16T17:22:21.527409Z",
     "iopub.status.idle": "2022-03-16T17:22:21.532501Z",
     "shell.execute_reply": "2022-03-16T17:22:21.532996Z",
     "shell.execute_reply.started": "2021-09-27T11:50:12.968168Z"
    },
    "papermill": {
     "duration": 0.036036,
     "end_time": "2022-03-16T17:22:21.533230",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.497194",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def time_bucket(x):\n",
    "    for i in reversed(range(0, 600, 50)):\n",
    "        if x >= i:\n",
    "            return i\n",
    "        \n",
    "def map_bucket(x, price_bucket):\n",
    "    try:\n",
    "        return price_bucket[int(x['time_id']), int(x['time_bucket'])]\n",
    "    except:\n",
    "        return np.nan"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "038eccdb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.590955Z",
     "iopub.status.busy": "2022-03-16T17:22:21.590195Z",
     "iopub.status.idle": "2022-03-16T17:22:21.598467Z",
     "shell.execute_reply": "2022-03-16T17:22:21.598990Z",
     "shell.execute_reply.started": "2021-09-27T11:50:13.027102Z"
    },
    "papermill": {
     "duration": 0.038191,
     "end_time": "2022-03-16T17:22:21.599203",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.561012",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# data directory\n",
    "data_dir = '../input/optiver-realized-volatility-prediction/'\n",
    "\n",
    "# Function to calculate first WAP\n",
    "def calc_wap1(df):\n",
    "    wap = (df['bid_price1'] * df['ask_size1'] + df['ask_price1'] * df['bid_size1']) / (df['bid_size1'] + df['ask_size1'])\n",
    "    return wap\n",
    "\n",
    "# Function to calculate second WAP\n",
    "def calc_wap2(df):\n",
    "    wap = (df['bid_price2'] * df['ask_size2'] + df['ask_price2'] * df['bid_size2']) / (df['bid_size2'] + df['ask_size2'])\n",
    "    return wap\n",
    "\n",
    "# Function to calculate the log of the return\n",
    "# Remember that logb(x / y) = logb(x) - logb(y)\n",
    "def log_return(series):\n",
    "    return np.log(series).diff()\n",
    "\n",
    "# Calculate the realized volatility\n",
    "def realized_volatility(series):\n",
    "    return np.sqrt(np.sum(series**2))\n",
    "\n",
    "# Function to count unique elements of a series\n",
    "def count_unique(series):\n",
    "    return len(np.unique(series))\n",
    "\n",
    "# Function to read our base train and test set\n",
    "def read_train_test():\n",
    "    train = pd.read_csv('../input/optiver-realized-volatility-prediction/train.csv')\n",
    "    test = pd.read_csv('../input/optiver-realized-volatility-prediction/test.csv')\n",
    "    # Create a key to merge with book and trade data\n",
    "    train['row_id'] = train['stock_id'].astype(str) + '-' + train['time_id'].astype(str)\n",
    "    test['row_id'] = test['stock_id'].astype(str) + '-' + test['time_id'].astype(str)\n",
    "    print(f'Our training set has {train.shape[0]} rows')\n",
    "    return train, test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "a64ec3aa",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.656367Z",
     "iopub.status.busy": "2022-03-16T17:22:21.655484Z",
     "iopub.status.idle": "2022-03-16T17:22:21.711899Z",
     "shell.execute_reply": "2022-03-16T17:22:21.711209Z",
     "shell.execute_reply.started": "2021-09-27T11:50:13.317809Z"
    },
    "papermill": {
     "duration": 0.086722,
     "end_time": "2022-03-16T17:22:21.712076",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.625354",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Function to preprocess book data (for each stock id)\n",
    "def book_preprocessor(file_path, file_path_trade,  forward_fill = False):\n",
    "    df = pd.read_parquet(file_path)\n",
    "    dft = pd.read_parquet(file_path_trade)\n",
    "    \n",
    "    if forward_fill:\n",
    "        df = df.set_index(['time_id', 'seconds_in_bucket'])\n",
    "        df = df.reindex(pd.MultiIndex.from_product([df_book.index.levels[0], np.arange(0, 600)], names=['time_id', 'seconds_in_bucket']), method='ffill')\n",
    "        df.reset_index(inplace=True)\n",
    "    df['idle_sum'] = df.groupby('time_id')['seconds_in_bucket'].transform(lambda x: x.diff())\n",
    "    df['idle_sum'].fillna(0, inplace = True)\n",
    "    \n",
    "    df['time_bucket'] = df['seconds_in_bucket'].apply(time_bucket)\n",
    "    dft['time_bucket'] = dft['seconds_in_bucket'].apply(time_bucket)\n",
    "    price_bucket = dft.groupby(['time_id', 'time_bucket'])['price'].mean().to_dict()\n",
    "    df['price'] = df.apply(map_bucket, args = (price_bucket, ), axis=1)\n",
    "    df['price'] = df.groupby('time_id')['price'].transform(lambda x: x.bfill())\n",
    "    df['bid1_price_ratio'] = (df['bid_price1'] / df['price'])*df['bid_size1']\n",
    "    df['ask1_price_ratio'] = (df['bid_price1'] / df['price'])*df['ask_size1']\n",
    "    \n",
    "    size_bucket = dft.groupby(['time_id', 'time_bucket'])['size'].mean().to_dict()\n",
    "    df['size'] = df.apply(map_bucket, args = (size_bucket, ), axis=1)\n",
    "    df['size'] = df.groupby('time_id')['size'].transform(lambda x: x.bfill())\n",
    "    \n",
    "    df['total_spread'] = (df['ask_size1'] * df['ask_price1']) - (df['bid_size1'] * df['bid_price1'])\n",
    "    df['total_spread_ratio'] = df['total_spread'] / df['price']\n",
    "    # Calculate Wap\n",
    "    df['wap1'] = calc_wap1(df)\n",
    "    df['wap2'] = calc_wap2(df)\n",
    "    #df['wap3'] = calc_wap3(df)\n",
    "    #df['wap4'] = calc_wap4(df)\n",
    "    # Calculate log returns\n",
    "    df['log_return1'] = df.groupby(['time_id'])['wap1'].apply(log_return)\n",
    "    df['log_return2'] = df.groupby(['time_id'])['wap2'].apply(log_return)\n",
    "    df['log_price'] = df['log_return1'] / df['price']\n",
    "    df['log_size'] = df['log_return1'] / df['size']\n",
    "    # Calculate wap balance\n",
    "    df['wap_balance'] = abs(df['wap1'] - df['wap2'])\n",
    "    df['wap_ratio'] = abs(df['wap1'] / df['wap2'])\n",
    "    # Calculate spread\n",
    "    df['price_spread'] = (df['ask_price1'] - df['bid_price1']) / ((df['ask_price1'] + df['bid_price1']) / 2)\n",
    "    df['price_spread2'] = (df['ask_price2'] - df['bid_price2']) / ((df['ask_price2'] + df['bid_price2']) / 2)\n",
    "    df['bid_spread'] = df['bid_price1'] - df['bid_price2']\n",
    "    df['ask_spread'] = df['ask_price1'] - df['ask_price2']\n",
    "    df[\"bid_ask_spread\"] = abs(df['bid_spread'] - df['ask_spread'])\n",
    "    df['total_volume'] = (df['ask_size1'] + df['ask_size2']) + (df['bid_size1'] + df['bid_size2'])\n",
    "    \n",
    "    df['volume_trade_size'] = df['total_volume'] / df['size']\n",
    "    \n",
    "    df['volume_imbalance'] = abs((df['ask_size1'] + df['ask_size2']) - (df['bid_size1'] + df['bid_size2']))\n",
    "    \n",
    "    # Dict for aggregations\n",
    "    create_feature_dict = {\n",
    "        #'wap1': [np.sum, np.std],\n",
    "        #'wap2': [np.sum, np.std],\n",
    "        #'ask_gradient':[np.var],\n",
    "        #'bid_gradient':[np.var],\n",
    "        'idle_sum':[np.mean, np.sum],\n",
    "        #'wap_ratio':[np.mean, np.var],\n",
    "        'log_return1': [realized_1],\n",
    "        'log_return2': [realized_1],\n",
    "        'wap_balance': [np.sum],\n",
    "        'wap_ratio': [np.mean],\n",
    "        'price_spread':[np.mean, np.var],\n",
    "        'price_spread2':[np.mean],\n",
    "        'bid_spread':[np.mean],\n",
    "        'ask_spread':[np.mean],\n",
    "        'total_volume':[np.sum],\n",
    "        'volume_imbalance':[np.sum, np.var],\n",
    "        \"bid_ask_spread\":[np.sum],\n",
    "        'ask1_price_ratio': [np.min, np.max],\n",
    "        'bid1_price_ratio':[np.min, np.max],\n",
    "        'total_spread_ratio':[np.mean],\n",
    "        'total_spread':[np.mean]\n",
    "    }\n",
    "    \n",
    "    create_feature_dict_time = {\n",
    "        'log_return1': [realized_volatility, realized_2],\n",
    "        'log_return2': [realized_volatility, realized_2],\n",
    "        'idle_sum': [np.sum, np.mean, tau],\n",
    "        'ask1_price_ratio': [np.mean, np.sum],\n",
    "        'log_price':[np.sum, realized_volatility],\n",
    "        'log_size':[realized_1, np.mean],\n",
    "        'bid1_price_ratio':[np.mean, np.sum],\n",
    "        'volume_trade_size':[np.var, np.sum],\n",
    "        'total_spread':[np.sum]\n",
    "    }\n",
    "    \n",
    "    # Function to get group stats for different windows (seconds in bucket)\n",
    "    def get_stats_window(fe_dict,seconds_in_bucket, add_suffix = False):\n",
    "        # Group by the window\n",
    "        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(fe_dict).reset_index()\n",
    "        # Rename columns joining suffix\n",
    "        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n",
    "        # Add a suffix to differentiate windows\n",
    "        if add_suffix:\n",
    "            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n",
    "        return df_feature\n",
    "    \n",
    "    # Get the stats for different windows\n",
    "    df_feature = get_stats_window(create_feature_dict,seconds_in_bucket = 0, add_suffix = False)\n",
    "    df_feature_500 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 500, add_suffix = True)\n",
    "    df_feature_400 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 400, add_suffix = True)\n",
    "    df_feature_300 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 300, add_suffix = True)\n",
    "    df_feature_200 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 200, add_suffix = True)\n",
    "    df_feature_100 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 100, add_suffix = True)\n",
    "\n",
    "    # Merge all\n",
    "    df_feature = df_feature.merge(df_feature_500, how = 'left', left_on = 'time_id_', right_on = 'time_id__500')\n",
    "    df_feature = df_feature.merge(df_feature_400, how = 'left', left_on = 'time_id_', right_on = 'time_id__400')\n",
    "    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n",
    "    df_feature = df_feature.merge(df_feature_200, how = 'left', left_on = 'time_id_', right_on = 'time_id__200')\n",
    "    df_feature = df_feature.merge(df_feature_100, how = 'left', left_on = 'time_id_', right_on = 'time_id__100')\n",
    "    # Drop unnecesary time_ids\n",
    "    df_feature.drop(['time_id__500','time_id__400', 'time_id__300', 'time_id__200','time_id__100'], axis = 1, inplace = True)\n",
    "    \n",
    "    bid_bucket = df.groupby(['time_id', 'time_bucket'])['bid_price1'].mean().reset_index().pivot(index = 'time_id',\n",
    "                                                                                                 columns = 'time_bucket',\n",
    "                                                                                                 values = 'bid_price1').reset_index(drop=True)\n",
    "    for bucket in range(0, 600, 50):\n",
    "        df_feature[bucket] = np.nan\n",
    "        df_feature[bucket].add_suffix('_bid')\n",
    "        if bucket not in bid_bucket.columns:\n",
    "            bid_bucket[bucket] = np.nan\n",
    "    #bid_bucket.drop('time_id',axis = 1, inplace = True)\n",
    "    bid_bucket = bid_bucket.add_suffix('_bid')\n",
    "    bid_bucket.fillna(bid_bucket.mean(axis=0), inplace = True)\n",
    "    df_feature[bid_bucket.columns] = np.nan\n",
    "    df_feature[bid_bucket.columns] = bid_bucket\n",
    "    bid_bucket = df.groupby(['time_id', 'time_bucket'])['ask_price1'].mean().reset_index().pivot(index = 'time_id',\n",
    "                                                                                                 columns = 'time_bucket',\n",
    "                                                                                                 values = 'ask_price1').reset_index(drop=True)\n",
    "    for bucket in range(0, 600, 50):\n",
    "        df_feature[bucket] = np.nan\n",
    "        df_feature[bucket].add_suffix('_ask')\n",
    "        if bucket not in bid_bucket.columns:\n",
    "            bid_bucket[bucket] = np.nan\n",
    "    #bid_bucket.drop('time_id',axis = 1, inplace = True)\n",
    "    bid_bucket = bid_bucket.add_suffix('_ask')\n",
    "    bid_bucket.fillna(bid_bucket.mean(axis=0), inplace = True)\n",
    "    df_feature[bid_bucket.columns] = np.nan\n",
    "    df_feature[bid_bucket.columns] = bid_bucket\n",
    "    #df_feature = pd.concat([df_feature, bid_bucket], axis=1)\n",
    "    \n",
    "    #empty columns, I don't know how???????????\n",
    "    useless = [i for i in range(0, 600, 50)]\n",
    "    df_feature.drop(useless, axis=1, inplace = True)\n",
    "    \n",
    "    # Create row_id so we can merge\n",
    "    stock_id = file_path.split('=')[1]\n",
    "    df_feature['row_id'] = df_feature['time_id_'].apply(lambda x: f'{stock_id}-{x}')\n",
    "    df_feature.drop(['time_id_'], axis = 1, inplace = True)\n",
    "    \n",
    "    return df_feature\n",
    "\n",
    "# Function to preprocess trade data (for each stock id)\n",
    "def trade_preprocessor(file_path):\n",
    "    df = pd.read_parquet(file_path)\n",
    "    #df_feature['rq_est1'] = df.groupby('time_id')['log_return'].agg(realized_1).reset_index().iloc[:, -1]\n",
    "    df['log_return'] = df.groupby('time_id')['price'].apply(log_return)\n",
    "    df['amount']=df['price']*df['size']\n",
    "    df['time_bucket'] = df['seconds_in_bucket'].apply(time_bucket)\n",
    "    # Dict for aggregations\n",
    "    create_feature_dict = {\n",
    "        'log_return':[realized_quadpower_quarticity],\n",
    "        #'seconds_in_bucket':[count_unique],\n",
    "        'size':[np.sum],\n",
    "        'order_count':[np.sum],\n",
    "        'amount':[np.sum, np.var],\n",
    "    }\n",
    "    create_feature_dict_time = {\n",
    "        'log_return':[realized_1],\n",
    "        #'seconds_in_bucket':[count_unique],\n",
    "        'size':[np.sum],\n",
    "        'order_count':[np.mean, tau],\n",
    "    }\n",
    "    # Function to get group stats for different windows (seconds in bucket)\n",
    "    def get_stats_window(fe_dict,seconds_in_bucket, add_suffix = False):\n",
    "        # Group by the window\n",
    "        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(fe_dict).reset_index()\n",
    "        # Rename columns joining suffix\n",
    "        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n",
    "        # Add a suffix to differentiate windows\n",
    "        if add_suffix:\n",
    "            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n",
    "        return df_feature\n",
    "    \n",
    "\n",
    "    # Get the stats for different windows\n",
    "    df_feature = get_stats_window(create_feature_dict,seconds_in_bucket = 0, add_suffix = False)\n",
    "    df_feature_500 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 500, add_suffix = True)\n",
    "    df_feature_400 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 400, add_suffix = True)\n",
    "    df_feature_300 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 300, add_suffix = True)\n",
    "    df_feature_200 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 200, add_suffix = True)\n",
    "    df_feature_100 = get_stats_window(create_feature_dict_time,seconds_in_bucket = 100, add_suffix = True)\n",
    "    \n",
    "        #market_breadth\n",
    "    df_feature['<=300s_price'] = (df[df.seconds_in_bucket <= 300].groupby('time_id')['amount'].sum() / df[df.seconds_in_bucket <= 300].groupby('time_id')['size'].sum()).reset_index().iloc[:, -1]\n",
    "    df_feature['>300s_price'] = (df[df.seconds_in_bucket > 300].groupby('time_id')['amount'].sum()/ df[df.seconds_in_bucket > 300].groupby('time_id')['size'].sum()).reset_index().iloc[:, -1]\n",
    "    df_feature[\"advance_decline\"] = df_feature['>300s_price'] - df_feature['<=300s_price']\n",
    "    df_feature[\"advance_decline\"] = df_feature[\"advance_decline\"].apply(np.sign)\n",
    "    df_feature.drop(['<=300s_price','>300s_price'], axis= 1, inplace = True)\n",
    "    \n",
    "    def tendency(price, vol):    \n",
    "        df_diff = np.diff(price)\n",
    "        val = (df_diff/price[1:])*100\n",
    "        power = np.sum(val*vol[1:])\n",
    "        return(power)\n",
    "    \n",
    "    lis = []\n",
    "    for n_time_id in df['time_id'].unique():\n",
    "        df_id = df[df['time_id'] == n_time_id]        \n",
    "        tendencyV = tendency(df_id['price'].values, df_id['size'].values)      \n",
    "        f_max = np.sum(df_id['price'].values > np.mean(df_id['price'].values))\n",
    "        f_min = np.sum(df_id['price'].values < np.mean(df_id['price'].values))\n",
    "        df_max =  np.sum(np.diff(df_id['price'].values) > 0)\n",
    "        df_min =  np.sum(np.diff(df_id['price'].values) < 0)\n",
    "        # new\n",
    "        abs_diff = np.median(np.abs( df_id['price'].values - np.mean(df_id['price'].values)))        \n",
    "        energy = np.mean(df_id['price'].values**2)\n",
    "        iqr_p = np.percentile(df_id['price'].values,75) - np.percentile(df_id['price'].values,25)\n",
    "        \n",
    "        # vol vars\n",
    "        \n",
    "        abs_diff_v = np.median(np.abs( df_id['size'].values - np.mean(df_id['size'].values)))        \n",
    "        energy_v = np.sum(df_id['size'].values**2)\n",
    "        iqr_p_v = np.percentile(df_id['size'].values,75) - np.percentile(df_id['size'].values,25)\n",
    "        \n",
    "        lis.append({'time_id':n_time_id,'tendency':tendencyV,'f_max':f_max,'f_min':f_min,'df_max':df_max,'df_min':df_min,\n",
    "                   'abs_diff':abs_diff,'energy':energy,'iqr_p':iqr_p,'abs_diff_v':abs_diff_v,'energy_v':energy_v,'iqr_p_v':iqr_p_v})\n",
    "    \n",
    "    df_lr = pd.DataFrame(lis)\n",
    "        \n",
    "   \n",
    "    df_feature = df_feature.merge(df_lr, how = 'left', left_on = 'time_id_', right_on = 'time_id')\n",
    "    \n",
    "    # Merge all\n",
    "    df_feature = df_feature.merge(df_feature_500, how = 'left', left_on = 'time_id_', right_on = 'time_id__500')\n",
    "    df_feature = df_feature.merge(df_feature_400, how = 'left', left_on = 'time_id_', right_on = 'time_id__400')\n",
    "    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n",
    "    df_feature = df_feature.merge(df_feature_200, how = 'left', left_on = 'time_id_', right_on = 'time_id__200')\n",
    "    df_feature = df_feature.merge(df_feature_100, how = 'left', left_on = 'time_id_', right_on = 'time_id__100')\n",
    "    # Drop unnecesary time_ids\n",
    "    df_feature.drop(['time_id__500','time_id__400', 'time_id__300', 'time_id__200','time_id','time_id__100'], axis = 1, inplace = True)\n",
    "    \n",
    "    df_feature = df_feature.add_prefix('trade_')\n",
    "    stock_id = file_path.split('=')[1]\n",
    "    df_feature['row_id'] = df_feature['trade_time_id_'].apply(lambda x:f'{stock_id}-{x}')\n",
    "    df_feature.drop(['trade_time_id_'], axis = 1, inplace = True)\n",
    "    return df_feature\n",
    "\n",
    "# Function to get group stats for the stock_id and time_id\n",
    "def get_time_stock(df):\n",
    "    vol_cols = ['log_return1_realized_1',\n",
    "                'log_return2_realized_1',\n",
    "                'log_return1_realized_volatility_400',\n",
    "                'log_return2_realized_volatility_400', \n",
    "                'log_return1_realized_volatility_100',\n",
    "                'log_return2_realized_volatility_100', \n",
    "                'trade_log_return_realized_quadpower_quarticity',\n",
    "               ]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    # Group by the stock id\n",
    "    df_time_id = df.groupby(['time_id'])[vol_cols].agg(['mean']).reset_index()\n",
    "    # Rename columns joining suffix\n",
    "    df_time_id.columns = ['_'.join(col) for col in df_time_id.columns]\n",
    "    df_time_id = df_time_id.add_suffix('_' + 'time')\n",
    "    \n",
    "    # Merge with original dataframe\n",
    "    df = df.merge(df_time_id, how = 'left', left_on = ['time_id'], right_on = ['time_id__time'])\n",
    "    df.drop('time_id__time', axis = 1, inplace = True)\n",
    "    return df\n",
    "    \n",
    "# Funtion to make preprocessing function in parallel (for each stock id)\n",
    "def preprocessor(list_stock_ids, is_train = True):\n",
    "    \n",
    "    # Parrallel for loop\n",
    "    def for_joblib(stock_id):\n",
    "        # Train\n",
    "        if is_train:\n",
    "            file_path_book = data_dir + \"book_train.parquet/stock_id=\" + str(stock_id)\n",
    "            file_path_trade = data_dir + \"trade_train.parquet/stock_id=\" + str(stock_id)\n",
    "        # Test\n",
    "        else:\n",
    "            file_path_book = data_dir + \"book_test.parquet/stock_id=\" + str(stock_id)\n",
    "            file_path_trade = data_dir + \"trade_test.parquet/stock_id=\" + str(stock_id)\n",
    "    \n",
    "        # Preprocess book and trade data and merge them\n",
    "        df_tmp = pd.merge(book_preprocessor(file_path_book, file_path_trade), trade_preprocessor(file_path_trade), on = 'row_id', how = 'left')\n",
    "        \n",
    "        # Return the merge dataframe\n",
    "        return df_tmp\n",
    "    \n",
    "    # Use parallel api to call paralle for loop\n",
    "    df = Parallel(n_jobs = -1, verbose = 1)(delayed(for_joblib)(stock_id) for stock_id in list_stock_ids)\n",
    "    # Concatenate all the dataframes that return from Parallel\n",
    "    df = pd.concat(df, ignore_index = True)\n",
    "    return df\n",
    "\n",
    "# Function to calculate the root mean squared percentage error\n",
    "def rmspe(y_true, y_pred):\n",
    "    return np.sqrt(np.mean(np.square((y_true - y_pred) / y_true)))\n",
    "\n",
    "# Function to early stop with root mean squared percentage error\n",
    "def feval_rmspe(y_pred, lgb_train):\n",
    "    y_true = lgb_train.get_label()\n",
    "    return 'RMSPE', rmspe(y_true, y_pred), False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "441b9544",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T17:22:21.772608Z",
     "iopub.status.busy": "2022-03-16T17:22:21.771630Z",
     "iopub.status.idle": "2022-03-16T19:53:27.813730Z",
     "shell.execute_reply": "2022-03-16T19:53:27.814337Z",
     "shell.execute_reply.started": "2021-09-27T11:50:13.430073Z"
    },
    "papermill": {
     "duration": 9066.076405,
     "end_time": "2022-03-16T19:53:27.814680",
     "exception": false,
     "start_time": "2022-03-16T17:22:21.738275",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Our training set has 428932 rows\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed: 58.4min\n",
      "[Parallel(n_jobs=-1)]: Done 112 out of 112 | elapsed: 150.9min finished\n",
      "[Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done   1 out of   1 | elapsed:    0.4s finished\n"
     ]
    }
   ],
   "source": [
    "# Read train and test\n",
    "train, test = read_train_test()\n",
    "# Get unique stock ids \n",
    "train_stock_ids = train['stock_id'].unique()\n",
    "#train = train[(train.stock_id == train_stock_ids[0]) | (train.stock_id == train_stock_ids[1])]\n",
    "# Preprocess them using Parallel and our single stock id functions\n",
    "train_ = preprocessor(train_stock_ids, is_train = True)\n",
    "train = train.merge(train_, on = ['row_id'], how = 'left')\n",
    "\n",
    "# Get unique stock ids \n",
    "test_stock_ids = test['stock_id'].unique()\n",
    "# Preprocess them using Parallel and our single stock id functions\n",
    "test_ = preprocessor(test_stock_ids, is_train = False)\n",
    "test = test.merge(test_, on = ['row_id'], how = 'left')\n",
    "\n",
    "# Get group stats of time_id and stock_id\n",
    "train = get_time_stock(train)\n",
    "test = get_time_stock(test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "80d03d29",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:27.874745Z",
     "iopub.status.busy": "2022-03-16T19:53:27.873991Z",
     "iopub.status.idle": "2022-03-16T19:53:31.185809Z",
     "shell.execute_reply": "2022-03-16T19:53:31.185230Z",
     "shell.execute_reply.started": "2021-09-27T11:54:06.369834Z"
    },
    "papermill": {
     "duration": 3.343592,
     "end_time": "2022-03-16T19:53:31.185956",
     "exception": false,
     "start_time": "2022-03-16T19:53:27.842364",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "train['adr'] = train.groupby('time_id')['trade_advance_decline'].transform(pos_neg_ratio)\n",
    "test['adr'] = test.groupby('time_id')['trade_advance_decline'].transform(pos_neg_ratio)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "3777c936",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:31.244742Z",
     "iopub.status.busy": "2022-03-16T19:53:31.243725Z",
     "iopub.status.idle": "2022-03-16T19:53:31.251771Z",
     "shell.execute_reply": "2022-03-16T19:53:31.252307Z",
     "shell.execute_reply.started": "2021-09-27T11:54:09.713843Z"
    },
    "papermill": {
     "duration": 0.039261,
     "end_time": "2022-03-16T19:53:31.252499",
     "exception": false,
     "start_time": "2022-03-16T19:53:31.213238",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "cluster_features = [\n",
    "    \"time_id\",\n",
    "    \"stock_id\",\n",
    "    \"row_id\",\n",
    "    \"idle_sum_sum_500\",\n",
    "    #\"idle_sum_sum_400\",\n",
    "    \"idle_sum_sum_300\",\n",
    "    #\"idle_sum_sum_200\",\n",
    "    \"idle_sum_sum_100\",\n",
    "    \"idle_sum_mean\",\n",
    "    #\"idle_sum_sum\",\n",
    "    \"bid_ask_spread_sum\",\n",
    "    #\"ask_spread_mean\",\n",
    "    #\"bid_spread_mean\",\n",
    "    #\"price_spread_var\",\n",
    "    \"total_volume_sum\",\n",
    "    \"wap_ratio_mean\",\n",
    "    'bid1_price_ratio_mean_500',\n",
    "    'bid1_price_ratio_mean_300',\n",
    "    'bid1_price_ratio_mean_100',\n",
    "    \n",
    "    \"trade_log_return_realized_quadpower_quarticity\",\n",
    "    \n",
    "    \"trade_order_count_mean_500\",\n",
    "    \n",
    "    \"trade_energy_v\",\n",
    "    \"trade_energy\",\n",
    "    \"trade_f_min\",\n",
    "    \"trade_f_max\",\n",
    "    \"trade_tendency\",\n",
    "    \"trade_advance_decline\",\n",
    "    \"trade_order_count_sum\",\n",
    "    \"trade_abs_diff\",\n",
    "    \"trade_df_max\",\n",
    "    \"trade_iqr_p_v\",\n",
    "    #\"trade_rq_est1\",\n",
    "    \n",
    "    \"log_return1_realized_volatility_500\",\n",
    "    #\"log_return1_realized_volatility_400\",\n",
    "    \"log_return1_realized_volatility_300\",\n",
    "    #\"log_return1_realized_volatility_200\",\n",
    "    \"log_return1_realized_volatility_100\",\n",
    "    \n",
    "    \"log_return2_realized_volatility_500\",\n",
    "    #\"log_return2_realized_volatility_400\",\n",
    "    \"log_return2_realized_volatility_300\",\n",
    "    #\"log_return2_realized_volatility_200\",\n",
    "    \"log_return2_realized_volatility_100\"\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "256612ec",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:31.313565Z",
     "iopub.status.busy": "2022-03-16T19:53:31.312470Z",
     "iopub.status.idle": "2022-03-16T19:53:32.692356Z",
     "shell.execute_reply": "2022-03-16T19:53:32.691666Z",
     "shell.execute_reply.started": "2021-09-27T11:54:09.721443Z"
    },
    "papermill": {
     "duration": 1.412698,
     "end_time": "2022-03-16T19:53:32.692515",
     "exception": false,
     "start_time": "2022-03-16T19:53:31.279817",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from sklearn.cluster import OPTICS\n",
    "# making agg features\n",
    "\n",
    "train_p = pd.read_csv('../input/optiver-realized-volatility-prediction/train.csv')\n",
    "train_p = train_p.pivot(index='time_id', columns='stock_id', values='target')\n",
    "\n",
    "corr = train_p.corr()\n",
    "\n",
    "ids = corr.index\n",
    "\n",
    "kmeans = OPTICS(min_samples = 2, max_eps = 0.75).fit(corr.values)\n",
    "#KMeans(n_clusters=3, random_state=0).fit(corr.values)\n",
    "#print(kmeans.labels_)\n",
    "\n",
    "l = []\n",
    "for n in range(np.max(kmeans.labels_) + 1):\n",
    "    l.append ( [ (x-1) for x in ( (ids+1)*(kmeans.labels_ == n)) if x > 0] )\n",
    "    \n",
    "\n",
    "mat = []\n",
    "matTest = []\n",
    "\n",
    "n = 0\n",
    "for ind in l:\n",
    "    if (len(ind) < 3):\n",
    "        continue\n",
    "    newDf = train.loc[train['stock_id'].isin(ind) , cluster_features]\n",
    "    newDf = newDf.groupby(['time_id']).agg(np.nanmean)\n",
    "    newDf.loc[:,'stock_id'] = str(n)+'c1'\n",
    "    mat.append ( newDf )\n",
    "    \n",
    "    newDf = test.loc[test['stock_id'].isin(ind) , cluster_features]    \n",
    "    newDf = newDf.groupby(['time_id']).agg(np.nanmean)\n",
    "    newDf.loc[:,'stock_id'] = str(n)+'c1'\n",
    "    matTest.append ( newDf )\n",
    "    \n",
    "    n+=1\n",
    "    \n",
    "mat1 = pd.concat(mat).reset_index()\n",
    "#mat1.drop(columns=['target'],inplace=True)\n",
    "\n",
    "mat2 = pd.concat(matTest).reset_index()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "4a77ed96",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:32.756701Z",
     "iopub.status.busy": "2022-03-16T19:53:32.755876Z",
     "iopub.status.idle": "2022-03-16T19:53:32.807125Z",
     "shell.execute_reply": "2022-03-16T19:53:32.806564Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.66468Z"
    },
    "papermill": {
     "duration": 0.087324,
     "end_time": "2022-03-16T19:53:32.807279",
     "exception": false,
     "start_time": "2022-03-16T19:53:32.719955",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:3: FutureWarning: Index.ravel returning ndarray is deprecated; in a future version this will return a view on self.\n",
      "  This is separate from the ipykernel package so we can avoid doing imports until\n",
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:7: FutureWarning: Index.ravel returning ndarray is deprecated; in a future version this will return a view on self.\n",
      "  import sys\n"
     ]
    }
   ],
   "source": [
    "mat2 = pd.concat([mat2,mat1.loc[mat1.time_id==5]])\n",
    "mat1 = mat1.pivot(index='time_id', columns='stock_id')\n",
    "mat1.columns = [\"_\".join(x) for x in mat1.columns.ravel()]\n",
    "mat1.reset_index(inplace=True)\n",
    "\n",
    "mat2 = mat2.pivot(index='time_id', columns='stock_id')\n",
    "mat2.columns = [\"_\".join(x) for x in mat2.columns.ravel()]\n",
    "mat2.reset_index(inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "3a7ce851",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:32.871246Z",
     "iopub.status.busy": "2022-03-16T19:53:32.870536Z",
     "iopub.status.idle": "2022-03-16T19:53:38.376197Z",
     "shell.execute_reply": "2022-03-16T19:53:38.375570Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.712876Z"
    },
    "papermill": {
     "duration": 5.540602,
     "end_time": "2022-03-16T19:53:38.376366",
     "exception": false,
     "start_time": "2022-03-16T19:53:32.835764",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "train = pd.merge(train,mat1,how='left',on='time_id')\n",
    "test = pd.merge(test,mat2,how='left',on='time_id')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "f1b539c6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.439650Z",
     "iopub.status.busy": "2022-03-16T19:53:38.438607Z",
     "iopub.status.idle": "2022-03-16T19:53:38.441317Z",
     "shell.execute_reply": "2022-03-16T19:53:38.442102Z",
     "shell.execute_reply.started": "2021-09-27T11:29:51.344301Z"
    },
    "papermill": {
     "duration": 0.037264,
     "end_time": "2022-03-16T19:53:38.442366",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.405102",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#assert train.columns[train.isnull().values.all(axis=0)].shape[0] == 0, \"Wackadoodle!\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "11b8a81e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.508667Z",
     "iopub.status.busy": "2022-03-16T19:53:38.507637Z",
     "iopub.status.idle": "2022-03-16T19:53:38.509904Z",
     "shell.execute_reply": "2022-03-16T19:53:38.510383Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.792623Z"
    },
    "papermill": {
     "duration": 0.037043,
     "end_time": "2022-03-16T19:53:38.510584",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.473541",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "features = [col for col in train.columns if col not in {\"time_id\", \"target\", \"row_id\"}]\n",
    "feats_nostock = [col for col in train.columns if col not in {\"time_id\", \"target\", \"row_id\", \"stock_id\"}]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "4627bae3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.569264Z",
     "iopub.status.busy": "2022-03-16T19:53:38.568539Z",
     "iopub.status.idle": "2022-03-16T19:53:38.572921Z",
     "shell.execute_reply": "2022-03-16T19:53:38.573496Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.801093Z"
    },
    "papermill": {
     "duration": 0.035592,
     "end_time": "2022-03-16T19:53:38.573690",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.538098",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "n_folds = 5\n",
    "n_models = 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "2c1317a0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.634259Z",
     "iopub.status.busy": "2022-03-16T19:53:38.633385Z",
     "iopub.status.idle": "2022-03-16T19:53:38.638791Z",
     "shell.execute_reply": "2022-03-16T19:53:38.638302Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.812569Z"
    },
    "papermill": {
     "duration": 0.037753,
     "end_time": "2022-03-16T19:53:38.638941",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.601188",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Create a KFold object\n",
    "kfold = GroupKFold(n_splits = 5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "d9d588c6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.701613Z",
     "iopub.status.busy": "2022-03-16T19:53:38.700873Z",
     "iopub.status.idle": "2022-03-16T19:53:38.704689Z",
     "shell.execute_reply": "2022-03-16T19:53:38.704146Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.823984Z"
    },
    "papermill": {
     "duration": 0.03652,
     "end_time": "2022-03-16T19:53:38.704842",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.668322",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "folds = np.zeros(train.shape[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "c0042a94",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.766680Z",
     "iopub.status.busy": "2022-03-16T19:53:38.765942Z",
     "iopub.status.idle": "2022-03-16T19:53:38.846793Z",
     "shell.execute_reply": "2022-03-16T19:53:38.847546Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.834827Z"
    },
    "papermill": {
     "duration": 0.115076,
     "end_time": "2022-03-16T19:53:38.847776",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.732700",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "for fold, (trn_ind, val_ind) in enumerate(kfold.split(train, groups = train.time_id)):\n",
    "    folds[val_ind] += fold"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "cde81618",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.909441Z",
     "iopub.status.busy": "2022-03-16T19:53:38.908716Z",
     "iopub.status.idle": "2022-03-16T19:53:38.913845Z",
     "shell.execute_reply": "2022-03-16T19:53:38.914385Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.871993Z"
    },
    "papermill": {
     "duration": 0.037741,
     "end_time": "2022-03-16T19:53:38.914602",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.876861",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Function to early stop with root mean squared percentage error\n",
    "def rmspe(y_true, y_pred):\n",
    "    return np.sqrt(np.mean(np.square((y_true - y_pred) / y_true)))\n",
    "\n",
    "def feval_rmspe(y_pred, lgb_train):\n",
    "    y_true = lgb_train.get_label()\n",
    "    return 'RMSPE', rmspe(y_true, y_pred), False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "24d21e80",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:38.974534Z",
     "iopub.status.busy": "2022-03-16T19:53:38.973770Z",
     "iopub.status.idle": "2022-03-16T19:53:40.592909Z",
     "shell.execute_reply": "2022-03-16T19:53:40.592433Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.879169Z"
    },
    "papermill": {
     "duration": 1.650241,
     "end_time": "2022-03-16T19:53:40.593081",
     "exception": false,
     "start_time": "2022-03-16T19:53:38.942840",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:2: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  \n"
     ]
    }
   ],
   "source": [
    "blend_train = train[['time_id', 'stock_id', 'row_id', 'target']]\n",
    "blend_train['lgb'] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "ad16b0f7",
   "metadata": {
    "collapsed": true,
    "execution": {
     "iopub.execute_input": "2022-03-16T19:53:40.652469Z",
     "iopub.status.busy": "2022-03-16T19:53:40.651788Z",
     "iopub.status.idle": "2022-03-16T22:38:47.751898Z",
     "shell.execute_reply": "2022-03-16T22:38:47.752814Z",
     "shell.execute_reply.started": "2021-09-27T11:54:10.900347Z"
    },
    "jupyter": {
     "outputs_hidden": true
    },
    "papermill": {
     "duration": 9907.133045,
     "end_time": "2022-03-16T22:38:47.754031",
     "exception": false,
     "start_time": "2022-03-16T19:53:40.620986",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style type='text/css'>\n",
       ".datatable table.frame { margin-bottom: 0; }\n",
       ".datatable table.frame thead { border-bottom: none; }\n",
       ".datatable table.frame tr.coltypes td {  color: #FFFFFF;  line-height: 6px;  padding: 0 0.5em;}\n",
       ".datatable .bool    { background: #DDDD99; }\n",
       ".datatable .object  { background: #565656; }\n",
       ".datatable .int     { background: #5D9E5D; }\n",
       ".datatable .float   { background: #4040CC; }\n",
       ".datatable .str     { background: #CC4040; }\n",
       ".datatable .time    { background: #40CC40; }\n",
       ".datatable .row_index {  background: var(--jp-border-color3);  border-right: 1px solid var(--jp-border-color0);  color: var(--jp-ui-font-color3);  font-size: 9px;}\n",
       ".datatable .frame tbody td { text-align: left; }\n",
       ".datatable .frame tr.coltypes .row_index {  background: var(--jp-border-color0);}\n",
       ".datatable th:nth-child(2) { padding-left: 12px; }\n",
       ".datatable .hellipsis {  color: var(--jp-cell-editor-border-color);}\n",
       ".datatable .vellipsis {  background: var(--jp-layout-color0);  color: var(--jp-cell-editor-border-color);}\n",
       ".datatable .na {  color: var(--jp-cell-editor-border-color);  font-size: 80%;}\n",
       ".datatable .sp {  opacity: 0.25;}\n",
       ".datatable .footer { font-size: 9px; }\n",
       ".datatable .frame_dimensions {  background: var(--jp-border-color3);  border-top: 1px solid var(--jp-border-color0);  color: var(--jp-ui-font-color3);  display: inline-block;  opacity: 0.6;  padding: 1px 10px 1px 5px;}\n",
       "</style>\n"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training fold 0\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/lightgbm/engine.py:148: UserWarning: Found `n_estimators` in params. Will use it instead of argument\n",
      "  _log_warning(\"Found `{}` in params. Will use it instead of argument\".format(alias))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 1.853733 seconds.\n",
      "You can set `force_col_wise=true` to remove the overhead.\n",
      "[LightGBM] [Info] Total Bins 111027\n",
      "[LightGBM] [Info] Number of data points in the train set: 343145, number of used features: 483\n",
      "[LightGBM] [Info] Start training from score 0.001799\n",
      "[250]\ttraining's rmse: 0.000313328\ttraining's RMSPE: 0.145139\tvalid_1's rmse: 0.00130793\tvalid_1's RMSPE: 0.217608\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training fold 1\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/lightgbm/engine.py:148: UserWarning: Found `n_estimators` in params. Will use it instead of argument\n",
      "  _log_warning(\"Found `{}` in params. Will use it instead of argument\".format(alias))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 2.042304 seconds.\n",
      "You can set `force_col_wise=true` to remove the overhead.\n",
      "[LightGBM] [Info] Total Bins 111094\n",
      "[LightGBM] [Info] Number of data points in the train set: 343145, number of used features: 484\n",
      "[LightGBM] [Info] Start training from score 0.001805\n",
      "[250]\ttraining's rmse: 0.000313119\ttraining's RMSPE: 0.144623\tvalid_1's rmse: 0.00126513\tvalid_1's RMSPE: 0.233311\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training fold 2\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/lightgbm/engine.py:148: UserWarning: Found `n_estimators` in params. Will use it instead of argument\n",
      "  _log_warning(\"Found `{}` in params. Will use it instead of argument\".format(alias))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 2.225294 seconds.\n",
      "You can set `force_col_wise=true` to remove the overhead.\n",
      "[LightGBM] [Info] Total Bins 111081\n",
      "[LightGBM] [Info] Number of data points in the train set: 343146, number of used features: 483\n",
      "[LightGBM] [Info] Start training from score 0.001801\n",
      "[250]\ttraining's rmse: 0.000314984\ttraining's RMSPE: 0.145575\tvalid_1's rmse: 0.00112333\tvalid_1's RMSPE: 0.21516\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training fold 3\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/lightgbm/engine.py:148: UserWarning: Found `n_estimators` in params. Will use it instead of argument\n",
      "  _log_warning(\"Found `{}` in params. Will use it instead of argument\".format(alias))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 2.451101 seconds.\n",
      "You can set `force_col_wise=true` to remove the overhead.\n",
      "[LightGBM] [Info] Total Bins 111020\n",
      "[LightGBM] [Info] Number of data points in the train set: 343146, number of used features: 484\n",
      "[LightGBM] [Info] Start training from score 0.001800\n",
      "[250]\ttraining's rmse: 0.000314984\ttraining's RMSPE: 0.14575\tvalid_1's rmse: 0.00119026\tvalid_1's RMSPE: 0.217445\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training fold 4\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/lightgbm/engine.py:148: UserWarning: Found `n_estimators` in params. Will use it instead of argument\n",
      "  _log_warning(\"Found `{}` in params. Will use it instead of argument\".format(alias))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 2.304928 seconds.\n",
      "You can set `force_col_wise=true` to remove the overhead.\n",
      "[LightGBM] [Info] Total Bins 111029\n",
      "[LightGBM] [Info] Number of data points in the train set: 343146, number of used features: 483\n",
      "[LightGBM] [Info] Start training from score 0.001796\n",
      "[250]\ttraining's rmse: 0.000314385\ttraining's RMSPE: 0.145899\tvalid_1's rmse: 0.00116773\tvalid_1's RMSPE: 0.21317\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n",
      "/opt/conda/lib/python3.7/site-packages/lightgbm/engine.py:148: UserWarning: Found `n_estimators` in params. Will use it instead of argument\n",
      "  _log_warning(\"Found `{}` in params. Will use it instead of argument\".format(alias))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 1.616747 seconds.\n",
      "You can set `force_col_wise=true` to remove the overhead.\n",
      "[LightGBM] [Info] Total Bins 111197\n",
      "[LightGBM] [Info] Number of data points in the train set: 428932, number of used features: 483\n",
      "[LightGBM] [Info] Start training from score 0.001800\n",
      "Our out of folds RMSPE is 0.22036636229590498\n"
     ]
    }
   ],
   "source": [
    "import lightgbm as lgb\n",
    "\n",
    "seed0=2021\n",
    "params0 = {'bagging_fraction': 0.6247240713084175,\n",
    "           'bagging_freq': 1, 'boosting_type': 'dart', 'categorical_column': 0,\n",
    "           'feature_fraction': 0.9802857225639665, 'learning_rate': 0.1031062124248497,\n",
    "           'min_child_samples': 32, 'min_child_weight': 26.973169683940732, 'n_estimators':421,\n",
    "           'objective':'rmse',\n",
    "           'n_jobs': -1, 'num_leaves': 1066,\n",
    "           'random_state':42,\n",
    "           'reg_alpha': 1.2999247474540088,\n",
    "           'reg_lambda': 1.8184977839317344}\n",
    "\n",
    "params1 = {'boosting_type': 'dart', 'categorical_column': 0, 'objective':'rmse',\n",
    "           'learning_rate': 0.1167477918474961,\n",
    "           'min_child_samples': 34, 'min_child_weight': 24.733795444735957,\n",
    "           'n_estimators': 182,\n",
    "           'n_jobs': -1, 'num_leaves': 268, 'reg_alpha': 2.479425579240586,\n",
    "           'reg_lambda': 0.2347046165637776, 'subsample': 0.46059222140633244}\n",
    "\n",
    "\n",
    "\n",
    "def train_and_evaluate_lgb(train, test, params, m):\n",
    "    # Hyperparammeters (just basic)\n",
    "    \n",
    "    features = [col for col in train.columns if col not in {\"time_id\", \"target\", \"row_id\"}]\n",
    "    test_predictions = np.zeros(test.shape[0])\n",
    "\n",
    "    \n",
    "    #kfold = KFold(n_splits = 5, random_state = 2021, shuffle = True)\n",
    "    # Iterate through each fold\n",
    "    for fold in range(n_folds):\n",
    "        print(f'Training fold {fold}')\n",
    "        x_train, x_val = train[folds != fold], train[folds == fold]\n",
    "        y_train, y_val = train.target[folds != fold], train.target[folds == fold]\n",
    "        # Root mean squared percentage error weights\n",
    "        train_weights = 1 / np.square(y_train)\n",
    "        train_dataset = lgb.Dataset(x_train[features], y_train, weight = train_weights)\n",
    "        val_dataset = lgb.Dataset(x_val[features], y_val)\n",
    "        model = lgb.train(params = params,\n",
    "                          train_set = train_dataset, \n",
    "                          valid_sets = [train_dataset, val_dataset], \n",
    "                          verbose_eval = 250,\n",
    "                          feval = feval_rmspe)\n",
    "        # Add predictions to the out of folds array\n",
    "        blend_train.loc[folds == fold, 'lgb'] = model.predict(x_val[features])\n",
    "        # Predict the test set\n",
    "        test_predictions += model.predict(test[features]) / (n_folds+1)\n",
    "        gc.collect()\n",
    "    train_weights = 1 / np.square(train.target.to_numpy())\n",
    "    train_dataset = lgb.Dataset(train[features], train.target, weight = train_weights)\n",
    "    model = lgb.train(params = params,\n",
    "                      train_set = train_dataset,\n",
    "                      verbose_eval = 250)\n",
    "    test_predictions += model.predict(test[features]) / (n_folds+1)\n",
    "    rmspe_score = rmspe(train.target, blend_train['lgb'])\n",
    "    print(f'Our out of folds RMSPE is {rmspe_score}')\n",
    "    # Return test predictions\n",
    "    return test_predictions\n",
    "# Traing and evaluate\n",
    "#predictions_lgb_1= train_and_evaluate_lgb(train, test,params0, 1)\n",
    "predictions_lgb = train_and_evaluate_lgb(train, test,params0, 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "8ff1c9c6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:47.987151Z",
     "iopub.status.busy": "2022-03-16T22:38:47.985815Z",
     "iopub.status.idle": "2022-03-16T22:38:47.990643Z",
     "shell.execute_reply": "2022-03-16T22:38:47.989973Z",
     "shell.execute_reply.started": "2021-09-27T11:56:12.675675Z"
    },
    "papermill": {
     "duration": 0.197539,
     "end_time": "2022-03-16T22:38:47.990815",
     "exception": false,
     "start_time": "2022-03-16T22:38:47.793276",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "77"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "gc.collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "4cd7b30a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:48.077306Z",
     "iopub.status.busy": "2022-03-16T22:38:48.076479Z",
     "iopub.status.idle": "2022-03-16T22:38:48.098361Z",
     "shell.execute_reply": "2022-03-16T22:38:48.097573Z",
     "shell.execute_reply.started": "2021-09-27T11:56:12.80217Z"
    },
    "papermill": {
     "duration": 0.067097,
     "end_time": "2022-03-16T22:38:48.098554",
     "exception": false,
     "start_time": "2022-03-16T22:38:48.031457",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>time_id</th>\n",
       "      <th>stock_id</th>\n",
       "      <th>row_id</th>\n",
       "      <th>target</th>\n",
       "      <th>lgb</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>5</td>\n",
       "      <td>0</td>\n",
       "      <td>0-5</td>\n",
       "      <td>0.004136</td>\n",
       "      <td>0.003702</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>11</td>\n",
       "      <td>0</td>\n",
       "      <td>0-11</td>\n",
       "      <td>0.001445</td>\n",
       "      <td>0.001657</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>16</td>\n",
       "      <td>0</td>\n",
       "      <td>0-16</td>\n",
       "      <td>0.002168</td>\n",
       "      <td>0.002462</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>31</td>\n",
       "      <td>0</td>\n",
       "      <td>0-31</td>\n",
       "      <td>0.002195</td>\n",
       "      <td>0.001997</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>62</td>\n",
       "      <td>0</td>\n",
       "      <td>0-62</td>\n",
       "      <td>0.001747</td>\n",
       "      <td>0.001589</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   time_id  stock_id row_id    target       lgb\n",
       "0        5         0    0-5  0.004136  0.003702\n",
       "1       11         0   0-11  0.001445  0.001657\n",
       "2       16         0   0-16  0.002168  0.002462\n",
       "3       31         0   0-31  0.002195  0.001997\n",
       "4       62         0   0-62  0.001747  0.001589"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "blend_train.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "dda102d9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:48.191180Z",
     "iopub.status.busy": "2022-03-16T22:38:48.190078Z",
     "iopub.status.idle": "2022-03-16T22:38:48.195776Z",
     "shell.execute_reply": "2022-03-16T22:38:48.196371Z",
     "shell.execute_reply.started": "2021-09-27T11:56:12.824367Z"
    },
    "papermill": {
     "duration": 0.053028,
     "end_time": "2022-03-16T22:38:48.196681",
     "exception": false,
     "start_time": "2022-03-16T22:38:48.143653",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "features = [col for col in train.columns if col not in {\"time_id\", \"target\", \"row_id\", \"stock_id\"}]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "eb865ca6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:48.282023Z",
     "iopub.status.busy": "2022-03-16T22:38:48.281010Z",
     "iopub.status.idle": "2022-03-16T22:38:53.956516Z",
     "shell.execute_reply": "2022-03-16T22:38:53.955397Z",
     "shell.execute_reply.started": "2021-09-27T11:56:12.83077Z"
    },
    "papermill": {
     "duration": 5.720325,
     "end_time": "2022-03-16T22:38:53.956689",
     "exception": false,
     "start_time": "2022-03-16T22:38:48.236364",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from numpy.random import seed\n",
    "seed(42)\n",
    "import tensorflow as tf\n",
    "tf.random.set_seed(42)\n",
    "from tensorflow import keras\n",
    "from tensorflow.keras import backend as K\n",
    "from tensorflow.keras import regularizers\n",
    "\n",
    "def root_mean_squared_per_error(y_true, y_pred):\n",
    "         return K.sqrt(K.mean(K.square( (y_true - y_pred)/ y_true )))\n",
    "    \n",
    "es = tf.keras.callbacks.EarlyStopping(\n",
    "    monitor='val_loss', patience=10, verbose=0,\n",
    "    mode='min',restore_best_weights=True)\n",
    "\n",
    "plateau = tf.keras.callbacks.ReduceLROnPlateau(\n",
    "    monitor='val_loss', factor=0.2, patience=5, verbose=0,\n",
    "    mode='min')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "58f5c8ae",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:54.040984Z",
     "iopub.status.busy": "2022-03-16T22:38:54.040340Z",
     "iopub.status.idle": "2022-03-16T22:38:54.270365Z",
     "shell.execute_reply": "2022-03-16T22:38:54.270842Z",
     "shell.execute_reply.started": "2021-09-27T11:56:17.79973Z"
    },
    "papermill": {
     "duration": 0.276656,
     "end_time": "2022-03-16T22:38:54.271052",
     "exception": false,
     "start_time": "2022-03-16T22:38:53.994396",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "42"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "K.clear_session()\n",
    "gc.collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "a3af53d5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:54.349161Z",
     "iopub.status.busy": "2022-03-16T22:38:54.348558Z",
     "iopub.status.idle": "2022-03-16T22:38:54.351961Z",
     "shell.execute_reply": "2022-03-16T22:38:54.352477Z",
     "shell.execute_reply.started": "2021-09-27T11:56:18.003655Z"
    },
    "papermill": {
     "duration": 0.044056,
     "end_time": "2022-03-16T22:38:54.352665",
     "exception": false,
     "start_time": "2022-03-16T22:38:54.308609",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "stock_embedding_size = 24\n",
    "weight_decay = 1e-4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "d0f41798",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:54.430662Z",
     "iopub.status.busy": "2022-03-16T22:38:54.429987Z",
     "iopub.status.idle": "2022-03-16T22:38:54.434877Z",
     "shell.execute_reply": "2022-03-16T22:38:54.435386Z",
     "shell.execute_reply.started": "2021-09-27T11:56:18.009908Z"
    },
    "papermill": {
     "duration": 0.045763,
     "end_time": "2022-03-16T22:38:54.435622",
     "exception": false,
     "start_time": "2022-03-16T22:38:54.389859",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from tensorflow.keras.layers import Dropout\n",
    "class MCDropout(Dropout): \n",
    "    def call(self, inputs): \n",
    "        return super().call(inputs, training=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "0615ee04",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:54.514782Z",
     "iopub.status.busy": "2022-03-16T22:38:54.513784Z",
     "iopub.status.idle": "2022-03-16T22:38:54.522187Z",
     "shell.execute_reply": "2022-03-16T22:38:54.522720Z",
     "shell.execute_reply.started": "2021-09-27T11:56:18.024604Z"
    },
    "papermill": {
     "duration": 0.049428,
     "end_time": "2022-03-16T22:38:54.522921",
     "exception": false,
     "start_time": "2022-03-16T22:38:54.473493",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def base_model():\n",
    "    \n",
    "    # Each instance will consist of two inputs: a single user id, and a single movie id\n",
    "    stock_id_input = keras.Input(shape=(1,), name='stock_id')\n",
    "    num_input = keras.Input(shape=(train[features].shape[1],), name='num_data')\n",
    "\n",
    "\n",
    "    #embedding, flatenning and concatenating\n",
    "    stock_embedded = keras.layers.Embedding(max(cat_data)+1, stock_embedding_size, \n",
    "                                           input_length=1, name='stock_embedding')(stock_id_input)\n",
    "    stock_flattened = keras.layers.Flatten()(stock_embedded)\n",
    "    out = keras.layers.Concatenate()([stock_flattened, num_input])\n",
    "    \n",
    "\n",
    "    out = keras.layers.Dense(256, activation='swish',\n",
    "                             kernel_initializer = 'he_normal')(out)\n",
    "    out = MCDropout(0.3)(out)\n",
    "    out = keras.layers.Dense(128, activation='swish',\n",
    "                             kernel_initializer = 'he_normal')(out)\n",
    "    out = MCDropout(0.3)(out)\n",
    "    out = keras.layers.Dense(64, activation='swish',\n",
    "                             kernel_initializer = 'he_normal')(out)\n",
    "    out = MCDropout(0.3)(out)\n",
    "        \n",
    "\n",
    "    #out = keras.layers.Concatenate()([out, num_input])\n",
    "\n",
    "    # A single output: our predicted rating\n",
    "    out = keras.layers.Dense(1, activation='linear', name='prediction')(out)\n",
    "    \n",
    "    model = keras.Model(\n",
    "    inputs = [stock_id_input, num_input],\n",
    "    outputs = out,\n",
    "    )\n",
    "    \n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "7e77da08",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:38:54.601496Z",
     "iopub.status.busy": "2022-03-16T22:38:54.600870Z",
     "iopub.status.idle": "2022-03-16T22:39:02.327394Z",
     "shell.execute_reply": "2022-03-16T22:39:02.326778Z",
     "shell.execute_reply.started": "2021-09-27T11:56:18.038617Z"
    },
    "papermill": {
     "duration": 7.766891,
     "end_time": "2022-03-16T22:39:02.327574",
     "exception": false,
     "start_time": "2022-03-16T22:38:54.560683",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "min_max_dict = {np.inf: train[features][np.isfinite(train[features])].max(), -np.inf: train[features][np.isfinite(train[features])].min()}\n",
    "\n",
    "train.replace({col: min_max_dict for col in train[features].columns}, inplace = True)\n",
    "min_max_dict = {np.inf: test[features][np.isfinite(test[features])].max(), -np.inf: test[features][np.isfinite(test[features])].min()}\n",
    "\n",
    "test.replace({col: min_max_dict for col in test[features].columns}, inplace = True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "06147485",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:39:02.409651Z",
     "iopub.status.busy": "2022-03-16T22:39:02.408893Z",
     "iopub.status.idle": "2022-03-16T22:39:02.422651Z",
     "shell.execute_reply": "2022-03-16T22:39:02.423123Z",
     "shell.execute_reply.started": "2021-09-27T11:56:18.310163Z"
    },
    "papermill": {
     "duration": 0.057861,
     "end_time": "2022-03-16T22:39:02.423332",
     "exception": false,
     "start_time": "2022-03-16T22:39:02.365471",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "mask = (train.stock_id != 31) & (train.time_id != 25504) |(train.stock_id != 31) & (train.time_id != 27174)|(train.stock_id != 31) & (train.time_id != 1544)|(train.stock_id != 81) & (train.time_id != 28319)|(train.stock_id != 27) & (train.time_id != 20551)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "2d0a5c74",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:39:02.501920Z",
     "iopub.status.busy": "2022-03-16T22:39:02.501221Z",
     "iopub.status.idle": "2022-03-16T22:39:02.506848Z",
     "shell.execute_reply": "2022-03-16T22:39:02.507307Z",
     "shell.execute_reply.started": "2021-09-27T11:56:18.322471Z"
    },
    "papermill": {
     "duration": 0.046657,
     "end_time": "2022-03-16T22:39:02.507510",
     "exception": false,
     "start_time": "2022-03-16T22:39:02.460853",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  \"\"\"Entry point for launching an IPython kernel.\n"
     ]
    }
   ],
   "source": [
    "blend_train['nn1'] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "1acb5285",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:39:02.587816Z",
     "iopub.status.busy": "2022-03-16T22:39:02.587131Z",
     "iopub.status.idle": "2022-03-16T22:39:02.591201Z",
     "shell.execute_reply": "2022-03-16T22:39:02.590454Z",
     "shell.execute_reply.started": "2021-09-27T11:59:56.114392Z"
    },
    "papermill": {
     "duration": 0.046409,
     "end_time": "2022-03-16T22:39:02.591366",
     "exception": false,
     "start_time": "2022-03-16T22:39:02.544957",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "mask31 = train.stock_id != 31"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "c9a54a8a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T22:39:02.688734Z",
     "iopub.status.busy": "2022-03-16T22:39:02.687669Z",
     "iopub.status.idle": "2022-03-16T23:27:38.037769Z",
     "shell.execute_reply": "2022-03-16T23:27:38.038328Z",
     "shell.execute_reply.started": "2021-09-27T12:01:04.773513Z"
    },
    "papermill": {
     "duration": 2915.407661,
     "end_time": "2022-03-16T23:27:38.038627",
     "exception": false,
     "start_time": "2022-03-16T22:39:02.630966",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  \"\"\"Entry point for launching an IPython kernel.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/3\n",
      "336/336 [==============================] - 9s 26ms/step - loss: 0.2954\n",
      "Epoch 2/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.2938\n",
      "Epoch 3/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.2935\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fold 0: 0.25955\n",
      "Epoch 1/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.4695\n",
      "Epoch 2/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.4573\n",
      "Epoch 3/3\n",
      "336/336 [==============================] - 7s 19ms/step - loss: 0.4506\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fold 1: 0.41237\n",
      "Epoch 1/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.2250\n",
      "Epoch 2/3\n",
      "336/336 [==============================] - 7s 19ms/step - loss: 0.2250\n",
      "Epoch 3/3\n",
      "336/336 [==============================] - 6s 19ms/step - loss: 0.2254\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fold 2: 0.22816\n",
      "Epoch 1/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.2733\n",
      "Epoch 2/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.2677\n",
      "Epoch 3/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.2639\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fold 3: 0.24725\n",
      "Epoch 1/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.5520\n",
      "Epoch 2/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.5518\n",
      "Epoch 3/3\n",
      "336/336 [==============================] - 7s 20ms/step - loss: 0.5647\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1676: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  self._setitem_single_column(ilocs[0], value, pi)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fold 4: 0.55547\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "21672"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "blend_train['nn'] = 0\n",
    "test_predictions_nn2 = np.zeros(test.shape[0])\n",
    "max_target = np.max(train['target'])\n",
    "min_target = np.min(train['target'])\n",
    "for fold in range(n_folds):\n",
    "    num_data = train.loc[folds != fold, features].to_numpy().astype('float32')\n",
    "    cat_data = train.loc[folds != fold, 'stock_id'].to_numpy().astype('int8')\n",
    "    y_train = train.loc[folds!= fold, 'target']\n",
    "    \n",
    "    num_data_val = train.loc[folds == fold, features].to_numpy().astype('float32')\n",
    "    cat_data_val = train.loc[folds == fold, 'stock_id'].to_numpy().astype('int8')\n",
    "    y_val = train.loc[folds == fold, 'target']\n",
    "    \n",
    "    \n",
    "    scaler = StandardScaler() \n",
    "    num_data = scaler.fit_transform(num_data)\n",
    "    num_data_val = scaler.transform(num_data_val)\n",
    "    num_data = np.where(np.isnan(num_data), 0, num_data)\n",
    "    num_data_val = np.where(np.isnan(num_data_val), 0, num_data_val)\n",
    "    \n",
    "    model = base_model()\n",
    "    model.compile(\n",
    "        keras.optimizers.Adam(learning_rate=0.005),\n",
    "        loss=root_mean_squared_per_error\n",
    "    )\n",
    "    \n",
    "    \n",
    "    model.fit([cat_data, num_data], \n",
    "              y_train,               \n",
    "              batch_size=1024,\n",
    "              epochs=500,\n",
    "              validation_data=([cat_data_val, num_data_val], y_val),\n",
    "              callbacks=[es, plateau],\n",
    "              validation_batch_size=len(y_val),\n",
    "              shuffle=True,\n",
    "             verbose = 0)\n",
    "    model.fit([cat_data, num_data], \n",
    "              y_train,               \n",
    "              batch_size=1024,\n",
    "              epochs=3)\n",
    "    preds = np.stack([model.predict([cat_data_val, num_data_val]).reshape(1,-1)[0].clip(min_target, max_target) for sample in range(10)]) \n",
    "    preds = preds.mean(axis=0)\n",
    "    blend_train.loc[folds == fold, 'nn'] = preds\n",
    "    score = round(rmspe(y_true = y_val, y_pred = preds),5)\n",
    "    print('Fold {}: {}'.format(fold, score))\n",
    "    num_data_test = scaler.transform(test[features].to_numpy())\n",
    "    #print(num_data_test)\n",
    "    num_data_test = np.where(np.isnan(num_data_test), 0, num_data_test)\n",
    "    #print(num_data_test)\n",
    "    num_data_test = tf.convert_to_tensor(num_data_test, dtype=tf.float32)\n",
    "    cat_test = tf.convert_to_tensor(test['stock_id'].to_numpy(), dtype = tf.int8)\n",
    "    preds = np.stack([model.predict([test['stock_id'], num_data_test]).reshape(1,-1)[0].clip(min_target, max_target) for sample in range(200)]) \n",
    "    preds = preds.mean(axis=0)\n",
    "    test_predictions_nn2 += preds /6\n",
    "    del model, num_data, num_data_val, cat_data, cat_data_val, y_train, y_val#,cat_test, num_data_test\n",
    "    K.clear_session()\n",
    "    gc.collect()\n",
    "    \n",
    "num_data = train.loc[mask31, features].to_numpy().astype('float32')\n",
    "cat_data = train.loc[mask31, 'stock_id'].to_numpy().astype('int8')\n",
    "\n",
    "scaler = StandardScaler()\n",
    "num_data = scaler.fit_transform(num_data)\n",
    "num_data = np.where(np.isnan(num_data), 0, num_data)\n",
    "\n",
    "model = base_model()\n",
    "model.compile(\n",
    "    keras.optimizers.Adam(learning_rate=0.006),\n",
    "    loss=root_mean_squared_per_error\n",
    ")\n",
    "\n",
    "\n",
    "model.fit([cat_data, num_data], \n",
    "          train.loc[mask31, 'target'],               \n",
    "          batch_size=1024,\n",
    "          epochs=70,\n",
    "          shuffle=True,\n",
    "         verbose = 0)\n",
    "\n",
    "num_data_test = scaler.transform(test[features].to_numpy())\n",
    "#print(num_data_test)\n",
    "num_data_test = np.where(np.isnan(num_data_test), 0, num_data_test)\n",
    "#print(num_data_test)\n",
    "num_data_test = tf.convert_to_tensor(num_data_test, dtype=tf.float32)\n",
    "cat_test = tf.convert_to_tensor(test['stock_id'].to_numpy(), dtype = tf.int8)\n",
    "preds = np.stack([model.predict([test['stock_id'], num_data_test]).reshape(1,-1)[0].clip(min_target, max_target) for sample in range(200)]) \n",
    "preds = preds.mean(axis=0)\n",
    "test_predictions_nn2 += preds /6\n",
    "del model, num_data, cat_data#,cat_test, num_data_test\n",
    "K.clear_session()\n",
    "gc.collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "9c2fe793",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T23:27:38.977132Z",
     "iopub.status.busy": "2022-03-16T23:27:38.976301Z",
     "iopub.status.idle": "2022-03-16T23:27:38.980527Z",
     "shell.execute_reply": "2022-03-16T23:27:38.980030Z",
     "shell.execute_reply.started": "2021-09-27T12:04:40.874759Z"
    },
    "papermill": {
     "duration": 0.503477,
     "end_time": "2022-03-16T23:27:38.980691",
     "exception": false,
     "start_time": "2022-03-16T23:27:38.477214",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:4: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  after removing the cwd from sys.path.\n",
      "/opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:5: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  \"\"\"\n"
     ]
    }
   ],
   "source": [
    "blend_cols = ['lgb', 'nn']\n",
    "\n",
    "blend_test = test[['time_id', 'stock_id', 'row_id']]\n",
    "blend_test['lgb'] = predictions_lgb\n",
    "blend_test['nn'] = test_predictions_nn2\n",
    "#blend_test[blend_cols] = np.concatenate((predictions_lgb_1, predictions_lgb_2, test_predictions_nn), axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "fbdb522d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T23:27:39.850582Z",
     "iopub.status.busy": "2022-03-16T23:27:39.849679Z",
     "iopub.status.idle": "2022-03-16T23:27:39.853981Z",
     "shell.execute_reply": "2022-03-16T23:27:39.853513Z",
     "shell.execute_reply.started": "2021-09-27T10:44:51.1735Z"
    },
    "papermill": {
     "duration": 0.439013,
     "end_time": "2022-03-16T23:27:39.854161",
     "exception": false,
     "start_time": "2022-03-16T23:27:39.415148",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"\\nfrom sklearn.linear_model import Ridge\\n\\npreds = np.zeros(test.shape[0])\\nfor fold in range(n_folds):\\n    x = blend_train.loc[folds != fold, blend_cols]\\n    y = blend_train.loc[folds != fold, 'target']\\n    reg = Ridge(fit_intercept = False)\\n    reg.fit(x, y)\\n    preds += reg.predict(blend_test[blend_cols]) / 5\\n    \\n\""
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'''\n",
    "from sklearn.linear_model import Ridge\n",
    "\n",
    "preds = np.zeros(test.shape[0])\n",
    "for fold in range(n_folds):\n",
    "    x = blend_train.loc[folds != fold, blend_cols]\n",
    "    y = blend_train.loc[folds != fold, 'target']\n",
    "    reg = Ridge(fit_intercept = False)\n",
    "    reg.fit(x, y)\n",
    "    preds += reg.predict(blend_test[blend_cols]) / 5\n",
    "    \n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "2c6ba984",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T23:27:40.718313Z",
     "iopub.status.busy": "2022-03-16T23:27:40.717316Z",
     "iopub.status.idle": "2022-03-16T23:27:40.721351Z",
     "shell.execute_reply": "2022-03-16T23:27:40.721866Z"
    },
    "papermill": {
     "duration": 0.434699,
     "end_time": "2022-03-16T23:27:40.722042",
     "exception": false,
     "start_time": "2022-03-16T23:27:40.287343",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#preds = blend_test[blend_cols].to_numpy()@weights.T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "c7a370bf",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T23:27:41.578584Z",
     "iopub.status.busy": "2022-03-16T23:27:41.577557Z",
     "iopub.status.idle": "2022-03-16T23:27:41.581345Z",
     "shell.execute_reply": "2022-03-16T23:27:41.581791Z"
    },
    "papermill": {
     "duration": 0.432629,
     "end_time": "2022-03-16T23:27:41.581964",
     "exception": false,
     "start_time": "2022-03-16T23:27:41.149335",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#blend_train.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "b57c6bc9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-16T23:27:42.433683Z",
     "iopub.status.busy": "2022-03-16T23:27:42.432632Z",
     "iopub.status.idle": "2022-03-16T23:27:42.455886Z",
     "shell.execute_reply": "2022-03-16T23:27:42.456506Z",
     "shell.execute_reply.started": "2021-09-27T12:05:15.494969Z"
    },
    "papermill": {
     "duration": 0.44957,
     "end_time": "2022-03-16T23:27:42.456704",
     "exception": false,
     "start_time": "2022-03-16T23:27:42.007134",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>row_id</th>\n",
       "      <th>target</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0-4</td>\n",
       "      <td>0.001341</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0-32</td>\n",
       "      <td>0.001964</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0-34</td>\n",
       "      <td>0.001983</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  row_id    target\n",
       "0    0-4  0.001341\n",
       "1   0-32  0.001964\n",
       "2   0-34  0.001983"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "test[\"row_id\"] = test[\"stock_id\"].astype(str) + \"-\" + test[\"time_id\"].astype(str) \n",
    "test[target_name] = (predictions_lgb + test_predictions_nn2) /2\n",
    "\n",
    "\n",
    "display(test[['row_id', target_name]].head(3))\n",
    "test[['row_id', target_name]].to_csv('submission.csv',index = False)\n",
    "#test[['row_id', target_name]].to_csv('submission.csv',index = False)\n",
    "#kmeans N=5 [0.2101, 0.21399, 0.20923, 0.21398, 0.21175]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c95e3678",
   "metadata": {
    "papermill": {
     "duration": 0.427444,
     "end_time": "2022-03-16T23:27:43.311910",
     "exception": false,
     "start_time": "2022-03-16T23:27:42.884466",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.10"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 21933.883609,
   "end_time": "2022-03-16T23:27:45.815972",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2022-03-16T17:22:11.932363",
   "version": "2.3.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
